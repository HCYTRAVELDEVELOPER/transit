{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "fs",
    "tool",
    "utils",
    "Promisify",
    "process",
    "require",
    "path",
    "semver",
    "Class",
    "define",
    "type",
    "statics",
    "__qxPathPromise",
    "getProjectData",
    "dir",
    "cwd",
    "qooxdooJsonPath",
    "join",
    "config",
    "Registry",
    "fileName",
    "data",
    "libraries",
    "applications",
    "existsAsync",
    "qooxdooJson",
    "Json",
    "loadJsonAsync",
    "lang",
    "Type",
    "isArray",
    "Manifest",
    "find",
    "lib",
    "push",
    "Compile",
    "app",
    "getLibraryPath",
    "Array",
    "length",
    "resolve",
    "Utils",
    "UserError",
    "getApplicationPath",
    "getQxPath",
    "scanAncestors",
    "root",
    "parse",
    "isQxLibrary",
    "npmdir",
    "getQxPathImpl",
    "res",
    "main",
    "filename",
    "__dirname",
    "exec",
    "trim",
    "applicationExists",
    "getQxVersion",
    "qxpath",
    "getLibraryVersion",
    "getCompilerVersion",
    "getAppQxVersion",
    "baseDir",
    "manifestRequiresKey",
    "manifestModel",
    "getInstance",
    "set",
    "warnOnly",
    "validate",
    "load",
    "qxVersion",
    "qxVersionRange",
    "getValue",
    "log",
    "Logger",
    "debug",
    "match",
    "sort",
    "reverse",
    "slice",
    "e",
    "valid",
    "Error",
    "libraryPath",
    "manifestPath",
    "manifest",
    "provides",
    "namespace",
    "getManifestModels",
    "registryModel",
    "manifestModels",
    "exists",
    "getLibraries",
    "library",
    "Abstract",
    "libPath",
    "version",
    "info"
  ],
  "sources": [
    "/home/andresf/workspace_qooxdoo/qooxdoo/qooxdoo-7.0/source/class/qx/tool/config/Utils.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2017-2021 The authors\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * John Spackman (john.spackman@zenesis.com, @johnspackman)\n     * Christian Boulanger (info@bibliograph.org, @cboulanger)\n\n************************************************************************ */\n\nconst fs = qx.tool.utils.Promisify.fs;\nconst process = require(\"process\");\nconst path = require(\"upath\");\nconst semver = require(\"semver\");\n\n/**\n * NOTE: some of the names of the methods in this class do not express very clearly\n * what they do and might be renamed before 7.0.0\n */\nqx.Class.define(\"qx.tool.config.Utils\", {\n  type: \"static\",\n  statics: {\n    /** @type{Promise<String} promise for cache of getQxPath() */\n    __qxPathPromise: null,\n\n    /**\n     * Returns data on the project in the currect working directory.\n     * If a qooxdoo.json file exists, the data is taken from there.\n     * If not, the relies on the following assumptions:\n     *\n     * 1. If a Manifest.json exists in the current working directory,\n     * it is assumed to be the main library directory.\n     *\n     * 2. If a compile.json file exists in the current working directory,\n     * it is assumed to be the directory in which the application can be found.\n     *\n     * The method returns a promise that resolves to a map containing the following keys:\n     * 'libraries': an array of maps containing a 'path' property with a relative path to a library folder,\n     * 'applications': an array of maps containing a 'path' property with a relative path to an\n     * application folder.\n     *\n     * If no libraries or applications can be found, empty arrays are returned.\n     *\n     * @param {String?} dir The base directory. If not given, the current working dir is used\n     * @return {Promise<Object>}\n     */\n    async getProjectData(dir = null) {\n      dir = dir || process.cwd();\n      let qooxdooJsonPath = path.join(\n        dir,\n        qx.tool.config.Registry.config.fileName\n      );\n\n      let data = {\n        libraries: [],\n        applications: []\n      };\n\n      if (await fs.existsAsync(qooxdooJsonPath)) {\n        let qooxdooJson = await qx.tool.utils.Json.loadJsonAsync(\n          qooxdooJsonPath\n        );\n\n        if (qx.lang.Type.isArray(qooxdooJson.libraries)) {\n          data.libraries = qooxdooJson.libraries;\n        }\n        if (qx.lang.Type.isArray(qooxdooJson.applications)) {\n          data.applications = qooxdooJson.applications;\n        }\n      }\n      if (\n        await fs.existsAsync(\n          path.join(dir, qx.tool.config.Manifest.config.fileName)\n        )\n      ) {\n        if (!data.libraries.find(lib => lib.path === \".\")) {\n          data.libraries.push({ path: \".\" });\n        }\n      }\n      if (\n        await fs.existsAsync(\n          path.join(dir, qx.tool.config.Compile.config.fileName)\n        )\n      ) {\n        if (!data.applications.find(app => app.path === \".\")) {\n          data.applications.push({ path: \".\" });\n        }\n      }\n      return data;\n    },\n\n    /**\n     * Returns the path to the library in the current working directory. If that\n     * directory contains several libraries, the first one found is returned.\n     *\n     * @param {String?} dir The base directory. If not given, the current working dir is used\n     * @throws {Error} Throws an error if no library can be found.\n     * @return {String} A promise that resolves with the absolute path to the library\n     */\n    async getLibraryPath(dir = null) {\n      dir = dir || process.cwd();\n      let { libraries } = await this.getProjectData(dir);\n      if (libraries instanceof Array && libraries.length) {\n        return path.resolve(process.cwd(), libraries[0].path);\n      }\n      throw new qx.tool.utils.Utils.UserError(\n        \"Cannot find library path - are you in the right directory?\"\n      );\n    },\n\n    /**\n     * Returns the path to the current application, depending on\n     * the current working directory. If a directory contains\n     * several applications, the first one found is returned.\n     *\n     * @param {String?} dir The base directory. If not given, the current working dir is used\n     * @throws {Error} Throws an error if no application can be found.\n     * @return {Promise<String>} A promise that resolves with the absolute path to the application\n     */\n    async getApplicationPath(dir = null) {\n      dir = dir || process.cwd();\n      let { applications } = await this.getProjectData(dir);\n      if (applications instanceof Array && applications.length) {\n        return path.resolve(process.cwd(), applications[0].path);\n      }\n      throw new qx.tool.utils.Utils.UserError(\n        \"Cannot find application path - are you in the right directory?\"\n      );\n    },\n\n    /**\n     * Compute the path to the qooxdoo library (the `qx` namespace)\n     * which is used independently of the application being compiled.\n     *\n     * The path will be resolved via the following strategies:\n     *\n     * 1. finding a `Manifest.json` in the current working directory that provides\n     * the `qx` library, or such a file in the parent directory, its parent dir,\n     * etc., up to the root.\n     *\n     * 2. The qx library contained in the projects `node_modules` folder, if it exists,\n     * or in the parent directory's, etc.\n     *\n     * 3. if not found try 1. and 2. with current script dir\n     *\n     * 4. A globally installed `@qooxdoo/framework` NPM package.\n     *\n     * If all strategies fail, an error is thrown.\n     *\n     * @param {String?} dir The base directory. If not given, the current working dir is used\n     * @return {Promise<*string>}\n     */\n    async getQxPath() {\n      if (this.__qxPathPromise) {\n        return await this.__qxPathPromise;\n      }\n\n      const scanAncestors = async dir => {\n        let root = path.parse(dir).root;\n        while (dir !== root) {\n          // 1. Manifest.json files\n          if (await this.isQxLibrary(dir)) {\n            return dir;\n          }\n          // 2. node_modules folders\n          let npmdir = path.join(dir, \"node_modules\", \"@qooxdoo\", \"framework\");\n          if (await this.isQxLibrary(npmdir)) {\n            return npmdir;\n          }\n          // walk up the directory tree\n          dir = path.resolve(path.join(dir, \"..\"));\n        }\n        return null;\n      };\n\n      const getQxPathImpl = async () => {\n        // 1. Look for the parent directory of the currently running command (eg `qx`)\n        let res = await scanAncestors(path.parse(require.main.filename).dir);\n        if (res) {\n          return res;\n        }\n\n        // 2. current dir\n        res = await scanAncestors(path.resolve(process.cwd()));\n        if (res) {\n          return res;\n        }\n\n        // 3. try script dir\n        /* eslint-disable-next-line @qooxdoo/qx/no-illegal-private-usage */\n        res = await scanAncestors(__dirname);\n        if (res) {\n          return res;\n        }\n\n        // 4. global npm package\n        let npmdir = (await qx.tool.utils.Utils.exec(\"npm root -g\")).trim();\n        res = path.join(npmdir, \"@qooxdoo\", \"framework\");\n        if (await this.isQxLibrary(res)) {\n          return res;\n        }\n\n        throw new qx.tool.utils.Utils.UserError(\n          `Path to the qx library cannot be determined.`\n        );\n      };\n\n      this.__qxPathPromise = getQxPathImpl();\n      return await this.__qxPathPromise;\n    },\n\n    /**\n     * Returns true if a compilable application exists in the given directory by checking\n     * if there is a \"compile.json\" file.\n     *\n     * @param {String?} dir The base directory. If not given, the current working dir is used\n     * @return {Promise<Boolean>}\n     */\n    async applicationExists(dir) {\n      return await fs.existsAsync(\n        path.join(dir, qx.tool.config.Compile.config.fileName)\n      );\n    },\n\n    /**\n     * Returns the qooxdoo version from the current environment (not the application)\n     * @param {String?} dir The base directory. If not given, the current working dir is used\n     * @return {Promise<String>}\n     */\n    async getQxVersion() {\n      let qxpath = await this.getQxPath();\n      return qx.tool.config.Utils.getLibraryVersion(qxpath);\n    },\n\n    /**\n     * returns the compiler version.\n     * The version is written during compiler compile into the enviroment\n     * @return {String}\n     */\n    getCompilerVersion() {\n      return qx.core.Environment.get(\"qx.compiler.version\");\n    },\n\n    /**\n     * Returns the qooxdoo version used in the application in the current or given\n     * directory. Throws if no such version can be determined\n     *\n     * @param {String?} baseDir The base directory. If not given, the current working dir is used\n     * @return {Promise<String>}\n     */\n    async getAppQxVersion(baseDir = null) {\n      baseDir = baseDir || process.cwd();\n      let manifestRequiresKey = \"@qooxdoo/framework\";\n      let manifestModel = await qx.tool.config.Manifest.getInstance()\n        .set({\n          baseDir,\n          warnOnly: true,\n          validate: false\n        })\n        .load();\n      let qxVersion;\n      let qxVersionRange = manifestModel.getValue(\n        `requires.${manifestRequiresKey}`\n      );\n\n      qx.log.Logger.debug(\n        `Manifest in ${baseDir} requires ${manifestRequiresKey}: ${qxVersionRange}`\n      );\n\n      if (qxVersionRange && !qxVersionRange.match(/[<>]/)) {\n        // cannot do comparisons\n        try {\n          // get the highest version mentioned with a tilde or caret range\n          qxVersion = qxVersionRange\n            .match(/[\\^~]?([-0-9a-z._]+)/g)\n            .sort()\n            .reverse()[0]\n            .slice(1);\n        } catch (e) {}\n      }\n      if (!qxVersion || !semver.valid(qxVersion)) {\n        throw new Error(\n          `Cannot determine the qooxdoo version used to compile the application. ` +\n            `Please specify a caret or tilde range for the requires.${manifestRequiresKey} key in the Manifest\")`\n        );\n      }\n      return qxVersion;\n    },\n\n    /**\n     * Returns true if the library in the given path provides the \"qx\" library\n     * @param {String} libraryPath\n     * @return {Promise<boolean>}\n     */\n    async isQxLibrary(libraryPath) {\n      let manifestPath = path.join(\n        libraryPath,\n        qx.tool.config.Manifest.config.fileName\n      );\n\n      if (!(await fs.existsAsync(manifestPath))) {\n        return false;\n      }\n      try {\n        let manifest = await qx.tool.utils.Json.loadJsonAsync(manifestPath);\n        if (manifest.provides && manifest.provides.namespace === \"qx\") {\n          return true;\n        }\n      } catch (e) {\n        throw new qx.tool.utils.Utils.UserError(\n          `Invalid manifest file ${manifestPath}.`\n        );\n      }\n      return false;\n    },\n\n    /**\n     * Returns an array of {@link qx.tool.config.Abstract} Objects which contain\n     * metadata on the `Manifest.json` file(s) in the current project/package.\n     * @param {String?} cwd The working directory. If not given, the current working dir is used\n     * @return {Promise<qx.tool.config.Manifest[]>}\n     */\n    async getManifestModels(cwd = null) {\n      cwd = cwd || process.cwd();\n      const registryModel = qx.tool.config.Registry.getInstance();\n      let manifestModels = [];\n      if (await registryModel.exists()) {\n        // we have a qooxdoo.json index file containing the paths of libraries in the repository\n        await registryModel.load();\n        let libraries = registryModel.getLibraries();\n        for (let library of libraries) {\n          manifestModels.push(\n            new qx.tool.config.Abstract(qx.tool.config.Manifest.config).set({\n              baseDir: path.join(cwd, library.path)\n            })\n          );\n        }\n      } else if (\n        await fs.existsAsync(qx.tool.config.Manifest.config.fileName)\n      ) {\n        manifestModels.push(qx.tool.config.Manifest.getInstance());\n      }\n      return manifestModels;\n    },\n\n    /**\n     * Given the path to a library folder, returns the library version from its manifest\n     * @param {String} libPath\n     * @return {Promise<String>} Version\n     */\n    async getLibraryVersion(libPath) {\n      let manifestPath = path.join(\n        libPath,\n        qx.tool.config.Manifest.config.fileName\n      );\n\n      let manifest = await qx.tool.utils.Json.loadJsonAsync(manifestPath);\n      if (!manifest) {\n        throw new Error(`No Manifest exists at ${manifestPath}.`);\n      }\n      let version;\n      try {\n        version = manifest.info.version;\n      } catch (e) {\n        throw new Error(`No valid version data in ${manifestPath}.`);\n      }\n      if (!semver.valid(version)) {\n        throw new qx.tool.utils.Utils.UserError(\n          `Manifest at ${manifestPath} contains invalid version number \"${version}\". Please use a semver compatible version.`\n        );\n      }\n      return version;\n    }\n  }\n});\n"
  ],
  "mappings": "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"
}