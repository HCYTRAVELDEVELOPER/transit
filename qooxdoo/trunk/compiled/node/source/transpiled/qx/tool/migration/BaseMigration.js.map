{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "process",
    "require",
    "fs",
    "tool",
    "utils",
    "Promisify",
    "fsp",
    "promises",
    "replaceInFile",
    "semver",
    "Class",
    "define",
    "type",
    "extend",
    "core",
    "Object",
    "construct",
    "runner",
    "setRunner",
    "properties",
    "check",
    "applied",
    "init",
    "pending",
    "members",
    "getVersion",
    "classname",
    "match",
    "replace",
    "getQxVersion",
    "getRunner",
    "config",
    "Utils",
    "announce",
    "message",
    "getVerbose",
    "compiler",
    "Console",
    "info",
    "markAsApplied",
    "param",
    "numberOfMigrations",
    "TypeError",
    "setApplied",
    "getApplied",
    "markAsPending",
    "setPending",
    "getPending",
    "renameFilesUnlessDryRun",
    "fileList",
    "dryRun",
    "getDryRun",
    "Assert",
    "assertArray",
    "filesToRename",
    "checkFilesToRename",
    "length",
    "newPath",
    "oldPath",
    "renameAsync",
    "debug",
    "e",
    "error",
    "exit",
    "existsAsync",
    "push",
    "checkFilesContain",
    "files",
    "text",
    "Array",
    "isArray",
    "file",
    "stat",
    "isFile",
    "readFile",
    "includes",
    "replaceInFilesUnlessDryRun",
    "replaceInFilesArr",
    "replaceInFiles",
    "from",
    "to",
    "updateDependencyUnlessDryRun",
    "manifestModel",
    "dependencyName",
    "semverRange",
    "oldRange",
    "getValue",
    "setValue",
    "updateQxDependencyUnlessDryRun",
    "qxVersion",
    "qxRange",
    "satisfies",
    "updateSchemaUnlessDryRun",
    "configModel",
    "schemaUri",
    "assertInstance",
    "Abstract",
    "getDataPath",
    "upgradePackagesUnlessDryRun",
    "options",
    "verbose",
    "cli",
    "commands",
    "package",
    "Upgrade",
    "migration",
    "BaseMigration"
  ],
  "sources": [
    "/home/andresf/workspace_qooxdoo/qooxdoo/qooxdoo-7.0/source/class/qx/tool/migration/BaseMigration.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2021 The authors\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Christian Boulanger (info@bibliograph.org, @cboulanger)\n\n************************************************************************ */\n\nconst process = require(\"process\");\nconst fs = qx.tool.utils.Promisify.fs;\nconst fsp = require(\"fs\").promises;\nconst replaceInFile = require(\"replace-in-file\");\nconst semver = require(\"semver\");\n\n/**\n * The base class for migrations, containing useful methods to\n * manipulate source files, and to update runtime information\n * on the individual migration class. It also holds a reference\n * to the runner which contains meta data for all migrations.\n */\nqx.Class.define(\"qx.tool.migration.BaseMigration\", {\n  type: \"abstract\",\n  extend: qx.core.Object,\n\n  /**\n   * Constructor\n   * @param {qx.tool.migration.Runner} runner The runner instance\n   */\n  construct(runner) {\n    super();\n    this.setRunner(runner);\n  },\n\n  properties: {\n    runner: {\n      check: \"qx.tool.migration.Runner\"\n    },\n\n    applied: {\n      check: \"Number\",\n      init: 0\n    },\n\n    pending: {\n      check: \"Number\",\n      init: 0\n    }\n  },\n\n  members: {\n    /**\n     * Returns the version of qooxdoo this migration applies to.\n     */\n    getVersion() {\n      return this.classname.match(/\\.M([0-9_]+)$/)[1].replace(/_/g, \".\");\n    },\n\n    /**\n     * Returns the qooxdoo version that has been passed to the Runner or the\n     * one from the environment\n     * @return {Promise<String>|*}\n     */\n    async getQxVersion() {\n      return (\n        (await this.getRunner().getQxVersion()) ||\n        qx.tool.config.Utils.getQxVersion()\n      );\n    },\n\n    /**\n     * Output message that announces a migration. What this does is to mark it\n     * visually\n     * @param message\n     */\n    announce(message) {\n      if (this.getRunner().getVerbose()) {\n        qx.tool.compiler.Console.info(\"*** \" + message);\n      }\n    },\n\n    /**\n     * Marks one or more migration steps as applied\n     * @param {Number|String} param Optional. If number, number of migrations to mark\n     * as applied, defaults to 1; if String, message to be `info()`ed if verbose=true\n     */\n    markAsApplied(param) {\n      let numberOfMigrations = 1;\n      if (typeof param == \"string\") {\n        if (this.getRunner().getVerbose()) {\n          qx.tool.compiler.Console.info(param);\n        }\n      } else if (typeof param == \"number\") {\n        numberOfMigrations = param;\n      } else if (typeof param != \"undefined\") {\n        throw new TypeError(\"Argument must be string or number\");\n      }\n      this.setApplied(this.getApplied() + numberOfMigrations);\n    },\n\n    /**\n     * Marks one or more migration steps as pending\n     * @param {Number|String} param Optional. If number, number of migrations to mark\n     * as pending, defaults to 1; if String, message to be `announce()`ed\n     */\n    markAsPending(param) {\n      let numberOfMigrations = 1;\n      if (typeof param == \"string\") {\n        if (this.getRunner().getVerbose()) {\n          this.announce(param);\n        }\n      } else if (typeof param == \"number\") {\n        numberOfMigrations = param;\n      } else if (typeof param != \"undefined\") {\n        throw new TypeError(\"Argument must be string or number\");\n      }\n      this.setPending(this.getPending() + numberOfMigrations);\n    },\n\n    /**\n     * Rename source files, unless this is a dry run, in which case\n     * it will only annouce it and mark the migration step as pending.\n     * @param {String[]} fileList Array containing arrays of [new name, old name]\n     */\n    async renameFilesUnlessDryRun(fileList) {\n      let dryRun = this.getRunner().getDryRun();\n      qx.core.Assert.assertArray(fileList);\n      let filesToRename = await this.checkFilesToRename(fileList);\n      if (filesToRename.length) {\n        if (dryRun) {\n          // announce migration\n          this.announce(`The following files will be renamed:`);\n          for (let [newPath, oldPath] of filesToRename) {\n            this.announce(`'${oldPath}' => '${newPath}'.`);\n          }\n          this.markAsPending();\n        } else {\n          // apply migration\n          for (let [newPath, oldPath] of filesToRename) {\n            try {\n              await fs.renameAsync(oldPath, newPath);\n              this.debug(`Renamed '${oldPath}' to '${newPath}'.`);\n            } catch (e) {\n              qx.tool.compiler.Console.error(\n                `Renaming '${oldPath}' to '${newPath}' failed: ${e.message}.`\n              );\n\n              process.exit(1);\n            }\n          }\n          this.markAsApplied();\n        }\n      }\n    },\n\n    /**\n     * Given an array of [newPath,oldPath], filter by those which exist\n     * at oldPath and not at newPath\n     * @param fileList {[]}\n     * @return {Promise<[]>}\n     */\n    async checkFilesToRename(fileList) {\n      let filesToRename = [];\n      for (let [newPath, oldPath] of fileList) {\n        if (\n          !(await fs.existsAsync(newPath)) &&\n          (await fs.existsAsync(oldPath))\n        ) {\n          filesToRename.push([newPath, oldPath]);\n        }\n      }\n      return filesToRename;\n    },\n\n    /**\n     * Checks if the given file or array of files contains a given text\n     * @param {String|String[]} files\n     * @param {String} text\n     * @return {Promise<Boolean>}\n     */\n    async checkFilesContain(files, text) {\n      files = Array.isArray(files) ? files : [files];\n      for (let file of files) {\n        if (\n          (await fsp.stat(file)).isFile() &&\n          (await fsp.readFile(file, \"utf8\")).includes(text)\n        ) {\n          return true;\n        }\n      }\n      return false;\n    },\n\n    /**\n     * Replace text in source files, unless this is a dry run, in which case\n     * it will only annouce it and mark the migration step as pending.\n     * @param {{files: string, from: string, to: string}[]} replaceInFilesArr\n     *    Array containing objects compatible with https://github.com/adamreisnz/replace-in-file\n     * @return {Promise<void>}\n     */\n    async replaceInFilesUnlessDryRun(replaceInFilesArr = []) {\n      qx.core.Assert.assertArray(replaceInFilesArr);\n      let dryRun = this.getRunner().getDryRun();\n      for (let replaceInFiles of replaceInFilesArr) {\n        if (\n          await this.checkFilesContain(\n            replaceInFiles.files,\n            replaceInFiles.from\n          )\n        ) {\n          if (dryRun) {\n            this.announce(\n              `In the file(s) ${replaceInFiles.files}, '${replaceInFiles.from}' will be changed to '${replaceInFiles.to}'.`\n            );\n\n            this.markAsPending();\n            continue;\n          }\n          try {\n            this.debug(\n              `Replacing '${replaceInFiles.from}' with '${replaceInFiles.to}' in ${replaceInFiles.files}`\n            );\n\n            await replaceInFile(replaceInFiles);\n            this.markAsApplied();\n          } catch (e) {\n            qx.tool.compiler.Console.error(\n              `Error replacing in files: ${e.message}`\n            );\n\n            process.exit(1);\n          }\n        }\n      }\n    },\n\n    /**\n     * Updates a dependency in the given Manifest model, , unless this is a dry run, in which case\n     * it will only annouce it and mark the migration step as pending.\n     * @param {qx.tool.config.Manifest} manifestModel\n     * @param {String} dependencyName The name of the dependency in the `require object\n     * @param {String} semverRange A semver-compatible range string\n     * @return {Promise<void>}\n     * @private\n     * @return {Promise<void>}\n     */\n    async updateDependencyUnlessDryRun(\n      manifestModel,\n      dependencyName,\n      semverRange\n    ) {\n      const oldRange = manifestModel.getValue(`requires.${dependencyName}`);\n      if (this.getRunner().getDryRun()) {\n        this.announce(\n          `Manifest version range for ${dependencyName} will be updated from ${oldRange} to ${semverRange}.`\n        );\n\n        this.markAsPending();\n      } else {\n        manifestModel.setValue(`requires.${dependencyName}`, semverRange);\n        this.markAsApplied();\n      }\n    },\n\n    /**\n     * Updates the `@qooxdoo/framework` dependency in the given Manifest model, if\n     * the current qooxdoo version is not covered by it. If this is a dry run, the\n     * change will only be annouced and the migration step marked as pending.\n     *\n     * @param {qx.tool.config.Manifest} manifestModel\n     * @return {Promise<void>}\n     */\n    async updateQxDependencyUnlessDryRun(manifestModel) {\n      let qxVersion = await this.getQxVersion();\n      let qxRange = manifestModel.getValue(\"requires.@qooxdoo/framework\");\n      if (!semver.satisfies(qxVersion, qxRange)) {\n        qxRange = `^${qxVersion}`;\n        await this.updateDependencyUnlessDryRun(\n          manifestModel,\n          \"@qooxdoo/framework\",\n          qxRange\n        );\n      }\n    },\n\n    /**\n     * Updates the json-schema in a configuration file, unless this is a dry run, in which case\n     * it will only annouce it and mark the migration step as pending.\n     * @param {qx.tool.config.Abstract} configModel\n     * @param {String} schemaUri\n     * @return {Promise<void>}\n     */\n    async updateSchemaUnlessDryRun(configModel, schemaUri) {\n      qx.core.Assert.assertInstance(configModel, qx.tool.config.Abstract);\n      if (configModel.getValue(\"$schema\") !== schemaUri) {\n        if (this.getRunner().getDryRun()) {\n          this.markAsPending(\n            `Schema version for ${configModel.getDataPath()} will be set to ${schemaUri}.`\n          );\n        } else {\n          configModel.setValue(\"$schema\", schemaUri);\n          this.markAsApplied(\n            `Schema version for ${configModel.getDataPath()} updated.`\n          );\n        }\n      }\n    },\n\n    /**\n     * Upgrades the applications's installed packages, unless this is a dry run, in which case\n     * it will only annouce it and mark the migration step as pending.\n     * @return {Promise<void>}\n     */\n    async upgradePackagesUnlessDryRun() {\n      const runner = this.getRunner();\n      if (runner.getDryRun()) {\n        this.announce(\"Packages will be upgraded.\");\n        this.markAsPending();\n      } else {\n        let options = {\n          verbose: runner.getVerbose(),\n          qxVersion: runner.getQxVersion()\n        };\n\n        await new qx.tool.cli.commands.package.Upgrade(options).process();\n        this.markAsApplied();\n      }\n    }\n  }\n});\n"
  ],
  "mappings": "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"
}